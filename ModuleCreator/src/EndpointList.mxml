<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:fx="http://ns.adobe.com/mxml/2009" 
		   xmlns:mx="library://ns.adobe.com/flex/mx">
	<fx:Declarations>
	</fx:Declarations>
	
	<mx:HBox horizontalGap="20">
		<mx:Accordion id="_accordian" resizeToContent="true" change="{ updateButtonEnables() }" openDuration="200" creationPolicy="all"/>
		<mx:VBox verticalGap="10">
			<mx:Button id="_addEndpointButton" label="Add Endpoint" click="{ onClickAddEndpoint() }" width="{_buttonWidth}"/>
			<mx:Button id="_removeEndpointButton" label="Remove Endpoint" click="{ onClickRemoveEndpoint() }" width="{_buttonWidth}"/>
			<mx:Button id="_moveEndpointUpButton" label="Move Up" click="{ onClickMoveUp() }" width="{_buttonWidth}"/>
			<mx:Button id="_moveEndpointDownButton" label="Move Down" click="{ onClickMoveDown() }" width="{_buttonWidth}"/>
			<mx:Button id="_sortButton" label="Sort" click="{ onClickSort() }" width="{_buttonWidth}" toolTip="Orders Endpoints by type, then name (stream endpoints) or widget x-position (control endpoints)"/>
			<mx:Spacer height="50"/>
			<mx:Label text="Controls without Widgets:"
					  visible="{ _controlsWithoutWidgets.dataProvider.length > 0 }"/>
			<mx:List id="_controlsWithoutWidgets"
					 width="{_buttonWidth}" 
					 editable="false"
					 visible="{ _controlsWithoutWidgets.dataProvider.length > 0 }"
					 change="{onChangeControlsWithoutWidgets()}"
					 rowCount="{ Math.max( 2, _controlsWithoutWidgets.dataProvider.length ) }"/>					 
		</mx:VBox>		
	</mx:HBox>
	
	<fx:Script>
		<![CDATA[

			import flexunit.framework.Assert;
			
			
			public function doInitialize( widgetLayout:WidgetLayout ):void
			{
				_widgetLayout = widgetLayout;
				_widgetLayout.addEventListener( Globals.widgetAssignmentModifiedEvent, onWidgetsChanged );
			}
			
			
			public function newFile():void
			{
				_newEndpointNumber = 0;

				removeEndpoints();
				
				updateButtonEnables();
				
				updateControlsWithoutWidgets();
			}
			
			
			public function validateContent():Boolean
			{
				var valid:Boolean = validateMyOwnContent();
				
				for( var i:int = 0; i < _accordian.numChildren; i++ )
				{
					var endpoint:Endpoint = _accordian.getChildAt( i ) as Endpoint;
					Assert.assertNotNull( endpoint );
					
					if( !endpoint.validateContent() )
					{
						if( valid )
						{
							_accordian.selectedIndex = i;
						}
						
						valid = false;
					}
				}

				return valid;
			}
			
			
			public function loadFromXML( xml:XMLList ):Boolean
			{
				for each( var endpointXML:XML in xml.Endpoint )
				{
					var endpoint:Endpoint = createNewEndpoint();
					
					if( !endpoint.loadFromXML( endpointXML ) )
					{
						trace( "Error loading endpoint from xml: " + endpointXML.toString() );
						_accordian.removeChildAt( _accordian.numChildren - 1 );
						continue;
					}
				}

				updateButtonEnables();
				
				return true;
			}
			
			
			public function saveToXML():XML
			{
				var xml:XML = new XML( "<EndpointInfo></EndpointInfo>" );

				for( var i:int = 0; i < _accordian.numChildren; i++ )
				{
					var endpoint:Endpoint = _accordian.getChildAt( i ) as Endpoint;
					Assert.assertNotNull( endpoint );
					
					xml.appendChild( endpoint.saveToXML() ); 
				}
				
				return xml;
			}	
			
			
			public function getEndpoint( endpointName:String ):Endpoint
			{
				for each( var endpoint:Endpoint in _accordian.getChildren() )
				{
					if( endpoint.label == endpointName ) 
					{
						return endpoint; 
					}
				}
				
				return null;
			}
			
			
			private function removeEndpoints():void
			{
				for( var i:int = 0; i < _accordian.numChildren; i++ )
				{
					var endpoint:Endpoint = _accordian.getChildAt( i ) as Endpoint;
					Assert.assertNotNull( endpoint );
					
					endpoint.free();
				}
				
				_accordian.removeAllChildren();
			}
			
			
			private function onEndpointNameChanged( event:Event ):void
			{
				for( var i:int = 0; i < _accordian.numChildren; i++ )
				{
					var endpoint:Endpoint = _accordian.getChildAt( i ) as Endpoint;
					Assert.assertNotNull( endpoint );

					endpoint.onEndpointNameChanged();
				}
			}
			
			
			private function validateMyOwnContent():Boolean
			{
				if( _accordian.numChildren == 0 )
				{
					_addEndpointButton.errorString = "You must create at least one Endpoint";
					return false;
				}
				else
				{
					_addEndpointButton.errorString = null;
					return true;
				}
			}
			
			
			private function get newEndpointName():String
			{
				_newEndpointNumber++;
				return "<New Endpoint #" + _newEndpointNumber.toString() + ">";
			}
			
			
			private function createNewEndpoint():Endpoint
			{
				var endpoint:Endpoint = new Endpoint;

				_accordian.addChild( endpoint );
				endpoint.doInitialize( _widgetLayout );
				endpoint.addEventListener( Globals.modifiedEvent, onEndpointChanged );
				endpoint.addEventListener( Globals.endpointRenamedEvent, onEndpointNameChanged );
				return endpoint;
			}
			
			private function onClickAddEndpoint():void
			{
				var endpoint:Endpoint = createNewEndpoint();
	
				endpoint.label = newEndpointName;

				_accordian.selectedChild = endpoint;
				
				updateButtonEnables();
				updateControlsWithoutWidgets();
				validateMyOwnContent();
				interfaceChanged();
			}

			private function onClickRemoveEndpoint():void
			{
				Assert.assertTrue( _accordian.selectedIndex >= 0 );

				var endpoint:Endpoint = _accordian.getChildAt( _accordian.selectedIndex ) as Endpoint;
				Assert.assertNotNull( endpoint );
				_widgetLayout.onRemovedEndpoint( endpoint );
				
				_accordian.removeChildAt( _accordian.selectedIndex );
				
				updateButtonEnables();
				updateControlsWithoutWidgets();
				validateMyOwnContent();
				interfaceChanged();
			}

			private function onClickMoveUp():void
			{
				Assert.assertTrue( _accordian.selectedIndex >= 1 );
				
				var endpoint:Endpoint = _accordian.getChildAt( _accordian.selectedIndex ) as Endpoint;
				Assert.assertNotNull( endpoint );
				
				_accordian.setChildIndex( endpoint, _accordian.selectedIndex - 1 );
				_accordian.selectedIndex--;
				
				updateButtonEnables();
				interfaceChanged();
			}

			private function onClickMoveDown():void
			{
				Assert.assertTrue( _accordian.selectedIndex >= 0 && _accordian.selectedIndex < _accordian.numChildren - 1 );

				var endpoint:Endpoint = _accordian.getChildAt( _accordian.selectedIndex ) as Endpoint;
				Assert.assertNotNull( endpoint );
				
				_accordian.setChildIndex( endpoint, _accordian.selectedIndex + 1 );
				_accordian.selectedIndex++;
				
				updateButtonEnables();
				interfaceChanged();
			}
			
			
			private function onClickSort():void
			{
				var endpoints:Vector.<Endpoint> = new Vector.<Endpoint>;
				var selectedEndpoint:Endpoint = _accordian.selectedChild as Endpoint;
				
				for( var i:int = 0; i < _accordian.numChildren; i++ )
				{
					endpoints.push( _accordian.getChildAt( i ) );
				}
				
				endpoints.sort( endpointSortFunction );
				
				for( i = 0; i < endpoints.length; i++ )
				{
					_accordian.setChildIndex( endpoints[ i ], i );
				}
								
				_accordian.selectedChild = selectedEndpoint;

				updateButtonEnables();
				interfaceChanged();
			}
			
			
			private function endpointSortFunction( endpoint1:Endpoint, endpoint2:Endpoint ):Number
			{
				return endpoint1.getOrder( endpoint2 );
			}
			
			
			private function updateButtonEnables():void
			{
				_removeEndpointButton.enabled = ( _accordian.selectedIndex >= 0 );
				
				_moveEndpointDownButton.enabled = ( _accordian.selectedIndex >= 0 && _accordian.selectedIndex < _accordian.numChildren - 1 );

				_moveEndpointUpButton.enabled = ( _accordian.selectedIndex > 0 );
				
				_sortButton.enabled = ( _accordian.numChildren > 1 );
			}

			
			private function onEndpointChanged( event:Event ):void
			{
				interfaceChanged();
				
				updateControlsWithoutWidgets();
			}
			
			
			private function updateControlsWithoutWidgets():void
			{
				var controlsWithoutWidgets:Array = new Array;
				
				for each( var endpoint:Endpoint in _accordian.getChildren() )
				{
					if( !endpoint.isControl )
					{
						continue;
					}
					
					if( !_widgetLayout.getWidget( endpoint ) )
					{
						controlsWithoutWidgets.push( endpoint.label );
					}
				}
				
				_controlsWithoutWidgets.dataProvider = controlsWithoutWidgets;
			}
			
			
			private function onChangeControlsWithoutWidgets():void
			{
				if( _controlsWithoutWidgets.selectedItem )
				{
					_accordian.selectedChild = getEndpoint( _controlsWithoutWidgets.selectedItem as String );
				}
			}
			
			
			private function onWidgetsChanged( event:Event ):void
			{
				updateControlsWithoutWidgets();
			}
			
			
			private function interfaceChanged():void
			{
				dispatchEvent( new Event( Globals.modifiedEvent ) );
				validateMyOwnContent();
			}			
			

			private var _newEndpointNumber:int; 
			private var _widgetLayout:WidgetLayout;
			
			private static const _buttonWidth:Number = 150;
		]]>
	</fx:Script>			
			
</mx:Canvas>

